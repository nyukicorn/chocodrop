<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ChocoDrop XR GLB Viewer</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: 'Inter', 'Noto Sans JP', system-ui, -apple-system, sans-serif;
      background: #01060f;
      color: #e2e8f0;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      z-index: 10;
    }
    #right-controls { display: flex; gap: 8px; align-items: center; }
    input[type="file"], input[type="url"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.7);
      color: #e2e8f0;
    }
    button {
      border-radius: 10px;
      border: 1px solid rgba(56, 189, 248, 0.8);
      background: linear-gradient(120deg, rgba(56, 189, 248, 0.85), rgba(56, 189, 248, 0.45));
      color: #0f172a;
      font-weight: 600;
      padding: 8px 12px;
      cursor: pointer;
    }
    #drop-hint {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(14, 165, 233, 0.16);
      border: 2px dashed rgba(56, 189, 248, 0.9);
      color: #e0f2fe;
      font-size: 1.2rem;
      z-index: 9;
    }
    #drop-hint[data-active="true"] { display: grid; }
    #status { font-size: 0.9rem; color: #cbd5e1; }
    canvas { display: block; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="ui">
    <div>
      <input id="url-input" type="url" placeholder="GLB/GLTF の URL を貼り付け (同一オリジン推奨)" spellcheck="false" />
      <div id="status">待機中</div>
    </div>
    <div id="right-controls">
      <label style="display:inline-block">
        <input id="file-input" type="file" accept=".glb,.gltf" style="max-width:180px" />
      </label>
      <button id="load-url">URL読込</button>
      <button id="reset">リセット</button>
    </div>
  </div>
  <div id="drop-hint">ここに GLB/GLTF をドロップ</div>
  <canvas id="xr-canvas"></canvas>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
    import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
    import { ARButton } from 'three/examples/jsm/webxr/ARButton.js';

    const canvas = document.querySelector('#xr-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.xr.enabled = true;
    document.body.appendChild(VRButton.createButton(renderer));
    // ARはQuestブラウザがAR対応なら利用可
    document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: [] }));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 3);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.2, 0);
    controls.update();

    // 環境
    scene.add(new THREE.HemisphereLight(0xffffff, 0x1e293b, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 5, 2);
    dir.castShadow = true;
    scene.add(dir);
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(6, 64),
      new THREE.MeshStandardMaterial({ color: 0x0b1221, roughness: 0.9, metalness: 0.05 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/libs/draco/');
    loader.setDRACOLoader(draco);

    let current = null;

    function setStatus(text, tone = 'info') {
      const el = document.querySelector('#status');
      el.textContent = text;
      el.style.color = tone === 'error' ? '#f87171' : tone === 'warn' ? '#fbbf24' : '#cbd5e1';
    }

    function clearScene() {
      if (current) {
        scene.remove(current);
        current.traverse?.(obj => {
          if (obj.isMesh) {
            obj.geometry?.dispose?.();
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => m?.dispose?.());
            } else {
              obj.material?.dispose?.();
            }
          }
        });
      }
      current = null;
    }

    function centerModel(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center); // 原点に合わせる
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = maxDim > 4 ? 4 / maxDim : 1;
      object.scale.multiplyScalar(scale);
      controls.reset();
      controls.target.set(0, size.y * 0.5, 0);
      camera.position.set(0, size.y * 0.6 + 1.2, Math.max(3, maxDim * 1.2));
      controls.update();
    }

    async function loadFromArrayBuffer(buffer, name = 'model') {
      setStatus(`${name} を読み込み中…`);
      try {
        const glb = await loader.parseAsync(buffer, '');
        clearScene();
        current = glb.scene;
        scene.add(current);
        centerModel(current);
        setStatus(`${name} を読み込みました`, 'info');
      } catch (error) {
        console.error(error);
        setStatus(`読み込み失敗: ${error?.message || error}`, 'error');
      }
    }

    async function loadFromURL(url) {
      setStatus('URL 取得中…');
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const buffer = await response.arrayBuffer();
        const name = url.split('/').pop() || 'model';
        await loadFromArrayBuffer(buffer, name);
      } catch (error) {
        console.error(error);
        setStatus(`URL 読み込み失敗: ${error?.message || error}`, 'error');
      }
    }

    // UI
    const fileInput = document.querySelector('#file-input');
    const urlInput = document.querySelector('#url-input');
    const loadUrlBtn = document.querySelector('#load-url');
    const resetBtn = document.querySelector('#reset');
    const dropHint = document.querySelector('#drop-hint');

    fileInput.addEventListener('change', async e => {
      const file = e.target.files?.[0];
      e.target.value = '';
      if (!file) return;
      const buffer = await file.arrayBuffer();
      loadFromArrayBuffer(buffer, file.name);
    });

    loadUrlBtn.addEventListener('click', () => {
      const url = urlInput.value.trim();
      if (!url) return setStatus('URL を入力してください', 'warn');
      loadFromURL(url);
    });

    resetBtn.addEventListener('click', () => {
      clearScene();
      setStatus('待機中');
    });

    window.addEventListener('dragover', e => {
      e.preventDefault();
      dropHint.dataset.active = 'true';
    });
    window.addEventListener('dragleave', e => {
      e.preventDefault();
      dropHint.dataset.active = 'false';
    });
    window.addEventListener('drop', async e => {
      e.preventDefault();
      dropHint.dataset.active = 'false';
      const file = e.dataTransfer?.files?.[0];
      if (!file) return;
      const buffer = await file.arrayBuffer();
      loadFromArrayBuffer(buffer, file.name);
    });

    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener('resize', onResize);

    renderer.setAnimationLoop(() => {
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
