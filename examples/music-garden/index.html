<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌸 音楽の花園 - ChocoDrop Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Arial', sans-serif;
            color: white;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            max-width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b9d, #c44569, #6c7b95);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .description {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .controls {
            text-align: center;
        }

        .control-item {
            margin: 8px 0;
            font-size: 13px;
            opacity: 0.8;
        }

        .emoji {
            display: inline-block;
            margin-right: 8px;
        }

        .highlight {
            color: #ff6b9d;
            font-weight: bold;
        }

        .demo-links {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .demo-link {
            padding: 12px 20px;
            background: rgba(20, 30, 60, 0.9);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .demo-link:hover {
            background: rgba(40, 50, 80, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        #audio-status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .audio-active {
            color: #4CAF50 !important;
        }

        .audio-inactive {
            color: #ff6b9d !important;
        }

        .music-icon {
            display: inline-block;
            animation: music-pulse 2.5s ease-in-out infinite;
            cursor: pointer;
            color: #ff6b9d;
            text-shadow: 0 0 10px currentColor;
        }

        .music-icon:hover {
            transform: scale(1.3);
            animation: music-dance 0.8s ease-in-out infinite;
        }

        @keyframes music-pulse {
            0%, 100% {
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                transform: scale(1.1);
                filter: brightness(1.3);
            }
        }

        @keyframes music-dance {
            0%, 100% {
                transform: scale(1.3) rotate(0deg);
            }
            25% {
                transform: scale(1.4) rotate(-5deg);
            }
            75% {
                transform: scale(1.4) rotate(5deg);
            }
        }

        /* ChocoDrop 動画要素が花に埋もれないようにする */
        video {
            z-index: 20 !important;
            position: relative !important;
        }

        /* ChocoDrop UI要素のz-index */
        .chocodrop-ui, .chocodrop-overlay {
            z-index: 100 !important;
        }
    </style>
</head>
<body>
    <div id="info">
        <div class="title">🌸 音楽の花園</div>
        <div class="description">
            歌声や音楽の海で冒険しよう
        </div>

        <div class="controls">
            <div class="control-item"><span class="emoji">🎵</span>歌うと花が咲きます</div>
            <div class="control-item"><span class="emoji">🌈</span>音程で色が変化</div>
            <div class="control-item"><span class="emoji">✨</span>リズムで光が踊る</div>
        </div>

        <div class="controls">
            <div class="control-item"><code>@</code>キー または <span class="music-icon">🍫</span> で起動</div>
            <div class="control-item">✨ 試してみて：</div>
            <div class="control-item highlight">「動画を中央に」「音楽を開始」</div>
        </div>
    </div>

    <div id="audio-status" class="audio-inactive">🎤 音声待機中...</div>

    <div class="demo-links">
        <a href="../basic/index.html" class="demo-link">🍫 魔法世界</a>
        <a href="../pixel-rpg/index.html" class="demo-link">🏰 RPG王国</a>
        <a href="../space/index.html" class="demo-link">🌌 宇宙空間</a>
        <a href="../pixel-ocean/index.html" class="demo-link">🌊 海底世界</a>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

    <!-- ChocoDrop Demo UMD -->
    <script src="../basic/chocodrop-demo.umd.min.js"></script>

    <script>
        console.log('🌸 Music Garden Loading...');
        console.log('THREE loaded:', typeof THREE !== 'undefined');

        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 1);  // 黒背景に変更

        // Three.js キャンバスのz-indexを設定（動画より背景に配置）
        renderer.domElement.style.position = 'fixed';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '1';

        document.body.appendChild(renderer.domElement);

        // 🌸 音楽に反応する花を作成（ダリアのような多層花びら）
        function createMusicFlower(x, y, z, scale = 1) {
            const flowerGroup = new THREE.Group();

            // より自然な花びらの配置パターン
            const petalRings = [
                // 外側のリング - 大きな花びら
                {
                    count: 12,
                    size: 2.5 * scale,
                    opacity: 0.8,
                    colors: [0xff6b9d, 0xff1493, 0xff69b4, 0xda70d6],
                    radius: 2.2 * scale,
                    zOffset: 0
                },
                // 中間のリング
                {
                    count: 16,
                    size: 1.8 * scale,
                    opacity: 0.85,
                    colors: [0x9b59b6, 0x8e44ad, 0xba68c8, 0xab47bc],
                    radius: 1.5 * scale,
                    zOffset: 0.1
                },
                // 内側のリング
                {
                    count: 20,
                    size: 1.2 * scale,
                    opacity: 0.9,
                    colors: [0x3498db, 0x2196f3, 0x03a9f4, 0x00bcd4],
                    radius: 0.8 * scale,
                    zOffset: 0.2
                }
            ];

            const allPetals = [];
            const allBaseColors = [];

            petalRings.forEach((ring, ringIndex) => {
                for (let i = 0; i < ring.count; i++) {
                    // 各花びらの角度（少しランダムさを加える）
                    const angle = (i / ring.count) * Math.PI * 2 + (Math.random() - 0.5) * 0.2;

                    // ダリアの花びらのような滑らかな形状
                    const width = ring.size * 0.3;
                    const height = ring.size;

                    const petalCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(-width * 0.5, height * 0.3, 0),
                        new THREE.Vector3(-width * 0.8, height * 0.6, 0),
                        new THREE.Vector3(-width * 0.5, height * 0.9, 0),
                        new THREE.Vector3(0, height, 0),
                        new THREE.Vector3(width * 0.5, height * 0.9, 0),
                        new THREE.Vector3(width * 0.8, height * 0.6, 0),
                        new THREE.Vector3(width * 0.5, height * 0.3, 0),
                        new THREE.Vector3(0, 0, 0)
                    ], true);

                    const points2D = [];
                    const curvePoints = petalCurve.getPoints(50);
                    curvePoints.forEach(p => {
                        points2D.push(new THREE.Vector2(p.x, p.y));
                    });

                    const petalShape = new THREE.Shape(points2D);

                    const geometry = new THREE.ShapeGeometry(petalShape, 32);

                    // 色をリング内でバリエーション（美しいグラデーション）
                    const colorIndex = Math.floor(Math.random() * ring.colors.length);
                    const baseColor = new THREE.Color(ring.colors[colorIndex]);

                    // グラデーション効果のために頂点カラーを設定
                    const colors = [];
                    const positions = geometry.attributes.position;
                    for (let j = 0; j < positions.count; j++) {
                        const y = positions.getY(j);
                        const intensity = y / height; // 高さに応じて色を変化

                        // ベースカラーから明度を調整
                        const hsl = {};
                        baseColor.getHSL(hsl);
                        const gradientColor = new THREE.Color().setHSL(
                            hsl.h + intensity * 0.1,
                            hsl.s,
                            Math.min(1, hsl.l + intensity * 0.3)
                        );
                        colors.push(gradientColor.r, gradientColor.g, gradientColor.b);
                    }
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    // 明るく美しいマテリアル
                    const material = new THREE.MeshBasicMaterial({
                        color: baseColor,
                        transparent: true,
                        opacity: ring.opacity * 0.9,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });

                    const petal = new THREE.Mesh(geometry, material);

                    // 花びらの位置と向き
                    const x_pos = Math.cos(angle) * ring.radius;
                    const y_pos = Math.sin(angle) * ring.radius;
                    petal.position.set(x_pos, y_pos, ring.zOffset);

                    // 花びらを中心に向ける + 少し立体感を出すため角度調整
                    petal.lookAt(0, 0, ring.zOffset + 1);
                    petal.rotation.z = angle;

                    // 少し花びらを立体的に配置
                    petal.rotation.x = (Math.random() - 0.5) * 0.4;
                    petal.rotation.y = (Math.random() - 0.5) * 0.4;

                    flowerGroup.add(petal);
                    allPetals.push(petal);
                    allBaseColors.push(baseColor);
                }
            });

            // 花の中心（グラデーションのある美しい中心）
            const centerGeometry = new THREE.CircleGeometry(0.4 * scale, 16);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                emissive: new THREE.Color(0xffa500),
                transparent: true,
                opacity: 0.9
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.z = 0.4;
            flowerGroup.add(center);

            // ✨ キラキラパーティクル効果を追加
            const particleCount = 100;
            const particlesGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                // 花の周りにランダムに配置
                const r = (Math.random() * 2 + 1) * scale;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                particlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                particlePositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                particlePositions[i * 3 + 2] = r * Math.cos(phi) * 0.3;

                // 虹色のパーティクル
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 0.8, 0.7);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
            }

            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.05 * scale,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(particlesGeometry, particleMaterial);
            flowerGroup.add(particles);

            flowerGroup.position.set(x, y, z);

            // アニメーション用データ
            flowerGroup.userData = {
                originalScale: scale,
                petals: allPetals,
                center: center,
                particles: particles,
                pulsePhase: Math.random() * Math.PI * 2,
                baseColors: allBaseColors,
                petalRings: petalRings
            };

            return flowerGroup;
        }

        // 🎵 Web Audio API セットアップ
        let audioContext;
        let analyser;
        let dataArray;
        let isAudioActive = false;

        function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                console.log('🎵 Audio context initialized');
            } catch (error) {
                console.warn('🚫 Audio context not supported:', error);
            }
        }

        function connectVideoToAudio(videoElement) {
            console.log('🔗 Attempting to connect video to audio...');
            console.log('📺 Video element:', videoElement);

            if (!audioContext || !analyser) {
                console.warn('🚫 Audio context not initialized, initializing now...');
                initAudioContext();
                if (!audioContext || !analyser) {
                    console.error('❌ Failed to initialize audio context');
                    return;
                }
            }

            try {
                console.log('🔊 AudioContext state before connection:', audioContext.state);

                // AudioContextがsuspendedの場合、再開する
                if (audioContext.state === 'suspended') {
                    console.log('⏸️ AudioContext is suspended, resuming...');
                    audioContext.resume().then(() => {
                        console.log('▶️ AudioContext resumed successfully');
                    }).catch(err => {
                        console.error('❌ Failed to resume AudioContext:', err);
                    });
                }

                // 既に接続されている場合はスキップ
                if (videoElement.audioSource) {
                    console.log('✅ Video already connected to audio');
                    return;
                }

                console.log('🎬 Creating MediaElementSource...');
                const source = audioContext.createMediaElementSource(videoElement);
                console.log('🎵 Connecting source to analyser...');
                source.connect(analyser);
                console.log('🔊 Connecting analyser to destination...');
                analyser.connect(audioContext.destination);

                // 接続済みマーク
                videoElement.audioSource = source;

                isAudioActive = true;
                updateAudioStatus('🎤 音声解析中...', 'audio-active');
                console.log('✅ Video successfully connected to audio analyser');

                // 音声データのテスト
                setTimeout(() => {
                    if (analyser && dataArray) {
                        analyser.getByteFrequencyData(dataArray);
                        const testVolume = dataArray.reduce((sum, freq) => sum + freq, 0) / dataArray.length / 255;
                        console.log('🧪 Audio test - Volume level:', testVolume);
                        if (testVolume > 0.01) {
                            console.log('🎵 Audio is being detected!');
                        } else {
                            console.log('🔇 No audio detected. Video might be muted or have no audio track.');
                        }
                    }
                }, 1000);

            } catch (error) {
                console.error('❌ Failed to connect video to audio:', error);
                console.log('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });

                if (error.name === 'InvalidStateError') {
                    console.log('⚠️ InvalidStateError - Video already connected to another AudioContext!');
                    console.log('💡 This means ChocoDrop is using its own AudioContext.');
                    console.log('🔧 Trying alternative approach...');

                    // 代替案：既存の audio から音声データをコピー
                    tryAlternativeAudioConnection(videoElement);
                } else if (error.name === 'NotSupportedError') {
                    console.log('❌ NotSupportedError - Audio context creation failed');
                } else {
                    console.log('❓ Unknown error:', error.name);
                }
            }
        }

        function tryAlternativeAudioConnection(videoElement) {
            console.log('🔄 Trying alternative audio connection method...');

            // 方法1: Web Audio API を使わずに、直接 video の音量を監視
            const alternativeMonitor = () => {
                if (videoElement.paused) return;

                // 簡易的な音量検出（完璧ではないが動作する）
                const currentTime = videoElement.currentTime;
                const duration = videoElement.duration;
                const volume = videoElement.volume;

                // 再生時間ベースの簡易パルス生成
                const timeBasedVolume = Math.sin(currentTime * 10) * 0.3 + 0.7;

                // 音楽が再生中なら花を反応させる
                if (currentTime > 0 && !videoElement.paused && volume > 0) {
                    // グローバル変数を設定して花のアニメーションを駆動
                    window.alternativeAudioData = {
                        volume: timeBasedVolume * volume,
                        isActive: true,
                        timestamp: Date.now()
                    };

                    if (!isAudioActive) {
                        isAudioActive = true;
                        updateAudioStatus('🎵 代替音声監視中...', 'audio-active');
                        console.log('✅ Alternative audio monitoring started');
                    }
                }
            };

            // 100ms毎に監視
            videoElement.alternativeMonitorInterval = setInterval(alternativeMonitor, 100);
            console.log('🔄 Alternative audio monitoring interval started');
        }

        function updateAudioStatus(text, className) {
            const status = document.getElementById('audio-status');
            status.textContent = text;
            status.className = className;
        }

        // 🌸 花畑を作成
        const flowers = [];
        const flowerPositions = [
            [0, 0, 0],      // 中央
            [-8, 2, -5],    // 左
            [8, -1, -3],    // 右
            [-3, -3, -8],   // 左奥
            [5, 3, -6],     // 右奥
            [0, 5, -10],    // 上奥
            [-6, -2, 3],    // 左手前
            [7, 1, 4]       // 右手前
        ];

        flowerPositions.forEach(pos => {
            const flower = createMusicFlower(pos[0], pos[1], pos[2], 0.8 + Math.random() * 0.4);
            flowers.push(flower);
            scene.add(flower);
        });

        // ✨ 環境光（全体を柔らかく照らす）
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);

        // 🌟 メインのポイントライト（花を美しく照らす）
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 50);
        pointLight.position.set(0, 10, 5);
        scene.add(pointLight);

        // 追加のライト（より立体的に）
        const spotLight = new THREE.SpotLight(0xff6b9d, 0.3);
        spotLight.position.set(-10, 10, 10);
        spotLight.target.position.set(0, 0, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        // 📷 カメラ設定
        camera.position.set(0, 3, 12);
        camera.lookAt(0, 0, 0);

        // 🎮 コントロール
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;

        // 🍫 ChocoDrop初期化
        console.log('🔍 Pre-ChocoDrop system check:');
        console.log('  - AudioContext support:', typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
        console.log('  - Video elements before ChocoDrop:', document.querySelectorAll('video').length);
        
        const chocoDrop = ChocoDrop.createChocoDrop(scene, {
            camera: camera,
            renderer: renderer,
            // GitHub Pagesなので生成機能なし、インポートのみ
            serverUrl: null,
            sceneOptions: {
                enableMouseInteraction: true
            },
            onControlsToggle: (disabled) => {
                controls.enabled = !disabled;
            },
            onVideoAdded: (videoObject) => {
                console.log('🎬 Video object added to scene:', videoObject);
                console.log('🔍 Video object type:', typeof videoObject);
                console.log('🔍 Video object constructor:', videoObject.constructor.name);
                
                // 🚨 重要: onVideoAddedが呼ばれていることを確認
                console.log('🚨 onVideoAdded callback was triggered!');
                console.log('🔍 DOM video elements at callback time:', document.querySelectorAll('video').length);
                
                // 🔍 ChocoDrop Three.js オブジェクト詳細調査
                console.log('🔍 Video object properties:', Object.keys(videoObject));
                console.log('🔍 Video object material:', videoObject.material);
                console.log('🔍 Video object material map:', videoObject.material?.map);
                console.log('🔍 Video object userData:', videoObject.userData);
                console.log('🔍 Video object children:', videoObject.children);
                
                // 🔍 Scene内の全オブジェクトを調査
                console.log('🔍 Scene children count:', scene.children.length);
                scene.traverse((child) => {
                    if (child.material && child.material.map && child.material.map.image) {
                        console.log('🔍 Found textured object:', child);
                        console.log('🔍 Texture image:', child.material.map.image);
                        console.log('🔍 Image tagName:', child.material.map.image.tagName);
                    }
                });

                // ChocoDrop オブジェクトから video 要素を直接取得する試み
                if (videoObject && videoObject.userData && videoObject.userData.videoElement) {
                    console.log('✅ Found video element in userData:', videoObject.userData.videoElement);
                    connectVideoToAudio(videoObject.userData.videoElement);
                    return;
                }

                // MaterialのmapからvideoElementを探す
                if (videoObject.material && videoObject.material.map && videoObject.material.map.image) {
                    const videoEl = videoObject.material.map.image;
                    if (videoEl.tagName === 'VIDEO') {
                        console.log('✅ Found video element in material.map.image:', videoEl);
                        connectVideoToAudio(videoEl);
                        return;
                    }
                }

                // ChocoDrop は Three.js オブジェクトを返すので、実際のvideo要素を探す
                console.log('🔍 Searching for video elements in 500ms...');
                setTimeout(() => {
                    const videoElements = document.querySelectorAll('video');
                    console.log(`📹 Found ${videoElements.length} video elements`);
                    console.log('🔊 AudioContext state:', audioContext ? audioContext.state : 'not initialized');
                    console.log('🎵 Analyser exists:', !!analyser);
                    console.log('📊 Data array exists:', !!dataArray);

                    if (videoElements.length === 0) {
                        console.warn('❌ No video elements found! ChocoDrop might not have added the video to DOM yet.');
                        // 再試行
                        setTimeout(() => {
                            console.log('🔄 Retrying video search...');
                            const retryVideos = document.querySelectorAll('video');
                            console.log(`📹 Retry found ${retryVideos.length} video elements`);
                            if (retryVideos.length > 0) {
                                retryVideos.forEach(v => connectVideoToAudio(v));
                            }
                        }, 2000);
                    }

                    videoElements.forEach((videoElement, index) => {
                        console.log(`🎥 Video ${index}:`);
                        console.log(`  - src: ${videoElement.src}`);
                        console.log(`  - readyState: ${videoElement.readyState}`);
                        console.log(`  - paused: ${videoElement.paused}`);
                        console.log(`  - volume: ${videoElement.volume}`);
                        console.log(`  - muted: ${videoElement.muted}`);
                        console.log(`  - audioTracks: ${videoElement.audioTracks ? videoElement.audioTracks.length : 'not supported'}`);
                        console.log(`  - duration: ${videoElement.duration}`);
                        console.log(`  - currentTime: ${videoElement.currentTime}`);

                        // まだ接続されていない動画要素を処理
                        if (!videoElement.audioSource) {
                            // 動画を前面に配置
                            videoElement.style.zIndex = '10';
                            videoElement.style.position = 'relative';

                            // すぐに接続を試みる
                            connectVideoToAudio(videoElement);

                            // 動画の準備ができてから再接続
                            videoElement.addEventListener('loadedmetadata', () => {
                                console.log('📹 Video metadata loaded, ensuring audio connection...');
                                if (!videoElement.audioSource) {
                                    connectVideoToAudio(videoElement);
                                }
                            });

                            // 再生開始時にも確実に接続
                            videoElement.addEventListener('play', () => {
                                console.log('▶️ Video playing, checking audio connection...');
                                if (!videoElement.audioSource) {
                                    connectVideoToAudio(videoElement);
                                }
                            });

                            // クリックで再生/一時停止（デバッグ用）
                            videoElement.addEventListener('click', () => {
                                if (videoElement.paused) {
                                    videoElement.play();
                                    // 再生開始時に強制的に音声アクティブ化
                                    setTimeout(() => {
                                        if (!isAudioActive) {
                                            console.log('🔧 Force activating audio monitoring...');
                                            isAudioActive = true;
                                            updateAudioStatus('🎵 強制音声監視中...', 'audio-active');

                                            // 代替監視を開始
                                            tryAlternativeAudioConnection(videoElement);
                                        }
                                    }, 100);
                                } else {
                                    videoElement.pause();
                                }
                            });
                        }
                    });
                }, 500);  // ChocoDrop が DOM に video 要素を追加するのを待つ
            }
        });

        // 音声コンテキストを初期化
        initAudioContext();
        
        // 🎵 DOM video要素を定期的に監視して音声接続
        function monitorVideoElements() {
            const videos = document.querySelectorAll('video');
            
            videos.forEach(video => {
                // まだ接続していない動画要素があれば接続
                if (!video.audioConnected && video.readyState >= 2) {
                    console.log('🎵 Found unconnected video, connecting audio:', video);
                    connectVideoToAudio(video);
                    video.audioConnected = true;
                }
            });
        }
        
        // 1秒ごとに監視
        setInterval(monitorVideoElements, 1000);
        
        // 初回実行
        setTimeout(monitorVideoElements, 2000);

        console.log('🍫 ChocoDrop Music Garden initialized');
        console.log('Press @ key to activate command interface');
        console.log('使用例: 🍫アイコンクリックでUI起動、動画を配置して音楽反応!');

        // 🎬 アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // 音声解析（デバッグ強化版）
            let volume = 0;
            let frequencies = new Array(8).fill(0);

            // デバッグ: 5秒ごとに状態をログ出力
            if (!window.lastDebugLog || Date.now() - window.lastDebugLog > 5000) {
                console.log('🔍 Audio Debug Status:');
                console.log('  - isAudioActive:', isAudioActive);
                console.log('  - analyser exists:', !!analyser);
                console.log('  - audioContext state:', audioContext ? audioContext.state : 'none');
                console.log('  - dataArray exists:', !!dataArray);
                console.log('  - video elements count:', document.querySelectorAll('video').length);
                console.log('  - alternative audio:', window.alternativeAudioData ? window.alternativeAudioData.isActive : 'none');
                window.lastDebugLog = Date.now();
            }

            if (isAudioActive && analyser) {
                analyser.getByteFrequencyData(dataArray);

                // 全体音量を計算
                volume = dataArray.reduce((sum, freq) => sum + freq, 0) / dataArray.length / 255;

                // デバッグ: 音量が検出されているか表示
                if (volume > 0.005) {
                    console.log('🎵 Audio detected! Volume:', volume.toFixed(3));
                    if (!window.audioDetected) {
                        updateAudioStatus('🎵 音楽反応中!', 'audio-active');
                        window.audioDetected = true;
                    }
                } else if (window.audioDetected) {
                    console.log('🔇 Audio stopped, volume:', volume.toFixed(3));
                    updateAudioStatus('🔇 音声待機中...', 'audio-waiting');
                    window.audioDetected = false;
                }

                // 周波数帯域を分析（低音〜高音）
                const bands = 8;
                const bandSize = Math.floor(dataArray.length / bands);
                for (let i = 0; i < bands; i++) {
                    let sum = 0;
                    for (let j = 0; j < bandSize; j++) {
                        sum += dataArray[i * bandSize + j];
                    }
                    frequencies[i] = sum / bandSize / 255;
                }
            } else if (window.alternativeAudioData && window.alternativeAudioData.isActive) {
                // 代替音声監視データを使用
                const altData = window.alternativeAudioData;
                const timeSinceUpdate = Date.now() - altData.timestamp;

                // 最新データ（1秒以内）の場合のみ使用
                if (timeSinceUpdate < 1000) {
                    volume = altData.volume;
                    // 簡易的な周波数データ生成
                    for (let i = 0; i < 8; i++) {
                        frequencies[i] = Math.sin(time * (i + 1) * 2) * volume * 0.5 + 0.5;
                    }

                    if (!window.alternativeAudioDetected) {
                        console.log('🔄 Using alternative audio data! Volume:', volume);
                        window.alternativeAudioDetected = true;
                    }
                }
            }

            // 🌸 花のアニメーション（ダリア版）
            flowers.forEach((flower, index) => {
                const userData = flower.userData;

                // 音楽検出時のみアニメーション
                if (volume > 0.005) { // 音楽がある程度大きい時のみ
                    // ベースのパルス（音楽に連動）
                    const basePulse = Math.sin(time + userData.pulsePhase) * 0.15 + 1;
                    
                    // 音楽に反応するスケール
                    const musicScale = 1 + volume * 0.4;
                    flower.scale.setScalar(userData.originalScale * basePulse * musicScale);
                } else {
                    // 音楽がない時は静止（オリジナルスケールのみ）
                    flower.scale.setScalar(userData.originalScale);
                }

                // 花びらリング別のアニメーション（音楽がある時のみ）
                userData.petals.forEach((petal, petalIndex) => {
                    const freqIndex = petalIndex % frequencies.length;
                    const intensity = frequencies[freqIndex];
                    const baseColor = userData.baseColors[petalIndex];

                    if (volume > 0.005) { // 音楽検出時のみアニメーション
                        const hsl = {};
                        baseColor.getHSL(hsl);

                        // 音楽に合わせて色相をシフト（お手本のような虹色効果）
                        const hueShift = intensity * 0.2;
                        const newHue = (hsl.h + hueShift) % 1;

                        // 彩度と明度も音楽に反応
                        const saturation = Math.max(0.6, hsl.s + intensity * 0.3);
                        const lightness = Math.max(0.4, hsl.l + intensity * 0.2);

                        petal.material.color.setHSL(newHue, saturation, lightness);

                        // リングごとの透明度調整（内側ほど濃く）
                        const ringIndex = Math.floor(petalIndex / 15);
                        const baseOpacity = userData.petalRings[Math.min(ringIndex, userData.petalRings.length - 1)].opacity;
                        petal.material.opacity = baseOpacity + intensity * 0.2;

                        // 個別の花びらの微細な動き
                        const petalPulse = Math.sin(time * 2 + petalIndex * 0.3) * intensity * 0.1;
                        petal.scale.setScalar(1 + petalPulse);

                        // 花びらの微細な回転
                        petal.rotation.z += (intensity * 0.01 + 0.002);
                    } else {
                        // 音楽がない時は静的な美しい色を保持
                        petal.material.color.copy(baseColor);
                        const ringIndex = Math.floor(petalIndex / 15);
                        const baseOpacity = userData.petalRings[Math.min(ringIndex, userData.petalRings.length - 1)].opacity;
                        petal.material.opacity = baseOpacity;
                        petal.scale.setScalar(1);
                    }
                });

                // 花の中心の発光と回転（音楽がある時のみ）
                if (userData.center && userData.center.material && userData.center.material.emissive) {
                    if (volume > 0.005) {
                        const centerIntensity = Math.max(0.5, volume * 1.5);
                        userData.center.material.emissive.setHSL(
                            (time * 0.3) % 1, // 虹色に変化
                            0.8,
                            centerIntensity * 0.6
                        );
                        userData.center.material.emissiveIntensity = centerIntensity;
                    } else {
                        // 音楽がない時は発光を抑制
                        userData.center.material.emissive.setRGB(0, 0, 0);
                        userData.center.material.emissiveIntensity = 0;
                    }
                }

                // 花全体の回転（音楽がある時のみ）
                if (volume > 0.005) {
                    flower.rotation.z += 0.005 + volume * 0.015;
                    
                    // 立体的な動き
                    flower.rotation.x = Math.sin(time * 0.3 + index) * 0.1;
                    flower.rotation.y = Math.cos(time * 0.2 + index) * 0.05;
                }

                // パーティクルのアニメーション（音楽がある時のみ）
                if (userData.particles) {
                    if (volume > 0.005) {
                        userData.particles.rotation.y += 0.01 + volume * 0.02;
                        userData.particles.rotation.z += 0.005;

                        // 音楽に合わせてパーティクルの明度を変化
                        userData.particles.material.opacity = 0.3 + volume * 0.5;
                    }
                }
            });

            // ライトも音楽に反応
            pointLight.intensity = 0.8 + volume * 0.5;
            pointLight.color.setHSL((time * 0.1) % 1, 0.5, 1);

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // 📱 レスポンシブ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>