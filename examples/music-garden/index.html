<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ¸ éŸ³æ¥½ã®èŠ±åœ’ - ChocoDrop Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Yu Gothic', 'Hiragino Sans', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
        }

        #info {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #f7fafc;
            background: rgba(30, 40, 60, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 14px 18px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 400;
            z-index: 100;
            max-width: 280px;
            line-height: 1.5;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #info.hidden {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            color: #cbd5e0;
            cursor: pointer;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #hint-toggle {
            position: fixed;
            top: 16px;
            left: 16px;
            background: rgba(139, 92, 246, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            z-index: 99;
            display: none;
            transition: all 0.2s ease;
            box-shadow: 0 1px 4px rgba(139, 92, 246, 0.2);
            animation: hint-sparkle 2.5s ease-in-out infinite;
        }

        #hint-toggle:hover {
            background: rgba(139, 92, 246, 0.25);
            transform: translateY(-1px) scale(1.05);
            animation: hint-sparkle-fast 1s ease-in-out infinite;
        }

        @keyframes hint-sparkle {
            0%, 100% {
                filter: brightness(1) drop-shadow(0 0 3px rgba(139, 92, 246, 0.3));
                transform: scale(1) rotate(0deg);
            }
            25% {
                filter: brightness(1.1) drop-shadow(0 0 6px rgba(139, 92, 246, 0.5));
                transform: scale(1.02) rotate(2deg);
            }
            50% {
                filter: brightness(1.2) drop-shadow(0 0 8px rgba(139, 92, 246, 0.7));
                transform: scale(1.05) rotate(0deg);
            }
            75% {
                filter: brightness(1.1) drop-shadow(0 0 6px rgba(139, 92, 246, 0.5));
                transform: scale(1.02) rotate(-2deg);
            }
        }

        @keyframes hint-sparkle-fast {
            0%, 100% {
                filter: brightness(1.1) drop-shadow(0 0 5px rgba(139, 92, 246, 0.6));
                transform: scale(1.05) rotate(0deg);
            }
            50% {
                filter: brightness(1.3) drop-shadow(0 0 10px rgba(139, 92, 246, 0.8));
                transform: scale(1.1) rotate(5deg);
            }
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            color: #cbd5e0;
            cursor: pointer;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #hint-toggle {
            position: fixed;
            top: 16px;
            left: 16px;
            background: rgba(30, 40, 60, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            z-index: 99;
            display: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #hint-toggle:hover {
            background: rgba(30, 40, 60, 1);
            transform: translateY(-1px);
        }

        .navigation {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        .nav-link {
            background: rgba(30, 40, 60, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #f7fafc;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .nav-link:hover {
            background: rgba(30, 40, 60, 1);
            transform: translateY(-1px);
        }

        .title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b9d, #c44569, #6c7b95);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .description {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .controls {
            text-align: center;
        }

        .control-item {
            margin: 8px 0;
            font-size: 13px;
            opacity: 0.8;
        }

        .emoji {
            display: inline-block;
            margin-right: 8px;
        }

        .highlight {
            color: #ff6b9d;
            font-weight: bold;
        }

        .navigation {
            position: fixed;
            top: 16px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        .nav-link {
            background: rgba(30, 40, 60, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #f7fafc;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .nav-link:hover {
            background: rgba(139, 92, 246, 0.2);
            transform: translateY(-1px);
        }

        .demo-links {
            position: fixed;
            bottom: 20px;
            right: 100px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .demo-link {
            padding: 12px 20px;
            background: rgba(20, 30, 60, 0.9);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .demo-link:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.5);
            transform: translateY(-2px);
        }

        #audio-status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .audio-active {
            color: #4CAF50 !important;
        }

        .audio-inactive {
            color: #ff6b9d !important;
        }

        .music-icon {
            display: inline-block;
            animation: music-pulse 2.5s ease-in-out infinite;
            cursor: pointer;
            color: #ff6b9d;
            text-shadow: 0 0 10px currentColor;
        }

        .music-icon:hover {
            transform: scale(1.3);
            animation: music-dance 0.8s ease-in-out infinite;
        }

        @keyframes music-pulse {
            0%, 100% {
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                transform: scale(1.1);
                filter: brightness(1.3);
            }
        }

        @keyframes music-dance {
            0%, 100% {
                transform: scale(1.3) rotate(0deg);
            }
            25% {
                transform: scale(1.4) rotate(-5deg);
            }
            75% {
                transform: scale(1.4) rotate(5deg);
            }
        }

        #info strong {
            font-size: 14px;
            font-weight: 600;
            color: #f7fafc;
            display: block;
            margin-bottom: 10px;
            text-align: center;
            letter-spacing: 0.5px;
        }

        #info code {
            background: rgba(255, 255, 255, 0.08);
            color: #f7fafc;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 11px;
        }

        .controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            font-size: 11px;
        }

        .control-item {
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
            min-width: fit-content;
        }

        /* ChocoDrop å‹•ç”»è¦ç´ ãŒèŠ±ã«åŸ‹ã‚‚ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ */
        video {
            z-index: 20 !important;
            position: relative !important;
        }

        /* ChocoDrop UIè¦ç´ ã®z-index */
        .chocodrop-ui, .chocodrop-overlay {
            z-index: 100 !important;
        }
    </style>
</head>
<body>
    <!-- Navigation Links -->
    <div class="navigation">
        <a href="../../index.html" class="nav-link">ğŸ  Home</a>
        <a href="https://github.com/nyukicorn/chocodrop" class="nav-link" target="_blank">ğŸ“¦ GitHub</a>
    </div>

    <!-- Hint Toggle Button (initially hidden) -->
    <button id="hint-toggle">ğŸ’¡</button>

    <!-- Main Info Panel -->
    <div id="info">
        <button class="close-btn" onclick="hideInfoPanel()">Ã—</button>
        <strong>ğŸŒ¸ éŸ³æ¥½ã®èŠ±åœ’ã¸ã‚ˆã†ã“ã</strong>

        ğŸ’¡ åŸºæœ¬æ“ä½œ:<br>
        1. å‹•ç”»ã‚„ç”»åƒã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã¿ã¦ï¼<br>
        2. ğŸµ æ­Œã†ã¨ãŠèŠ±ãŒå’²ãã®ã‚’ã‚„ã£ã¦ã¿ã¦ï¼<br>
        3. è¦–ç‚¹æ“ä½œ: ChocoDrop / ã¡ã‚‡ã“ãƒ‰ãƒ­ãƒƒãƒ—ã‚’æœ€å°åŒ–ã—ã¦ãƒ‰ãƒ©ãƒƒã‚°<br>
        4. ğŸŒˆéŸ³ç¨‹å¤‰åŒ–ã‚’ã‚„ã£ã¦ã¿ã¦ï¼(éŸ³æ¥½ã§è‰²ãŒå¤‰ã‚ã‚Šã¾ã™)<br>

        <div class="controls">
            <div class="control-item">
                <span class="key">@</span>
                <span>ChocoDropèµ·å‹•</span>
            </div>
            <div class="control-item">
                <span class="key">ğŸ«</span>
                <span>å³ä¸‹ãƒœã‚¿ãƒ³ã‹ã‚‰ã‚‚èµ·å‹•å¯</span>
            </div>
        </div>
    </div>

    <div id="audio-status" class="audio-inactive">ğŸ¤ éŸ³å£°å¾…æ©Ÿä¸­...</div>

    <div class="demo-links">
        <a href="../basic/index.html" class="demo-link">ğŸ« ã¯ã˜ã¾ã‚Šã®å›½</a>
        <a href="../wabi-sabi/index.html" class="demo-link">ğŸ–¤ ä¾˜ã³å¯‚ã³</a>
        <a href="../toy-city/index.html" class="demo-link">ğŸ¡ AIéŠåœ’åœ°</a>
        <a href="../space/index.html" class="demo-link">ğŸŒŒ å®‡å®™ç©ºé–“</a>
        <a href="../pixel-ocean/index.html" class="demo-link">ğŸŒŠ æµ·åº•ä¸–ç•Œ</a>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

    <!-- ChocoDrop Demo UMD -->
    <script src="../basic/chocodrop-demo.umd.min.js"></script>

    <script>
        console.log('ğŸŒ¸ Music Garden Loading...');
        console.log('THREE loaded:', typeof THREE !== 'undefined');

        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 1);  // é»’èƒŒæ™¯ã«å¤‰æ›´

        // Three.js ã‚­ãƒ£ãƒ³ãƒã‚¹ã®z-indexã‚’è¨­å®šï¼ˆå‹•ç”»ã‚ˆã‚ŠèƒŒæ™¯ã«é…ç½®ï¼‰
        renderer.domElement.style.position = 'fixed';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '1';

        document.body.appendChild(renderer.domElement);

        // ğŸŒ¸ éŸ³æ¥½ã«åå¿œã™ã‚‹èŠ±ã‚’ä½œæˆï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã§æ§‹æˆã•ã‚ŒãŸèŠ±ï¼‰
        function createMusicFlower(x, y, z, scale = 1) {
            const flowerGroup = new THREE.Group();

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç·æ•°ï¼ˆå¤šã„ã»ã©å¯†åº¦ãŒé«˜ã„ï¼‰
            const particleCount = 15000;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            // ãƒãƒ©ã®ã‚ˆã†ãªæ»‘ã‚‰ã‹ãªå±¤çŠ¶æ§‹é€ 
            for (let i = 0; i < particleCount; i++) {
                // ã©ã®å±¤ã«å±ã™ã‚‹ã‹ï¼ˆ0=ä¸­å¿ƒã€1=å¤–å´ï¼‰
                const layerProgress = Math.pow(Math.random(), 0.5);

                // æ˜ç¢ºãªå±¤ã‚’ä½œã‚‹ï¼ˆ15å±¤ï¼‰
                const layerIndex = Math.floor(layerProgress * 15);
                const layerNormalized = layerIndex / 15;

                // å±¤ã®ã‚µã‚¤ã‚º
                const layerRadius = layerNormalized * 2.6 * scale;

                // å±¤å†…ã§ã®è§’åº¦ä½ç½®
                const angle = Math.random() * Math.PI * 2;

                // å±¤ã®ä¸­ã§ã®åŠå¾„ä½ç½®ï¼ˆã‚ˆã‚Šå‡ç­‰ã«åˆ†æ•£ï¼‰
                const radialPos = Math.pow(Math.random(), 0.5);
                const innerRadius = layerRadius * 0.85;
                const outerRadius = layerRadius * 1.05;
                const radius = innerRadius + (outerRadius - innerRadius) * radialPos;

                // åŸºæœ¬çš„ãªXYä½ç½®
                let px = Math.cos(angle) * radius;
                let py = Math.sin(angle) * radius;

                // èŠ±ã³ã‚‰ã®æ³¢æ‰“ã¡ï¼ˆæ»‘ã‚‰ã‹ã«6ã¤ã®èŠ±ã³ã‚‰ï¼‰
                const petalCount = 6;
                const petalAngle = angle * petalCount;
                const waviness = Math.sin(petalAngle) * 0.12 * layerRadius * radialPos;
                px += Math.cos(angle) * waviness;
                py += Math.sin(angle) * waviness;

                // Zåº§æ¨™ï¼ˆæ»‘ã‚‰ã‹ãªã‚«ãƒƒãƒ—çŠ¶ã®æ›²é¢ï¼‰
                // å„å±¤ãŒå†…å´ã«æ¹¾æ›²
                const cupDepth = Math.pow(1 - radialPos, 3) * 0.4 * scale;
                const layerHeight = layerNormalized * 1.2 * scale;
                let pz = layerHeight - cupDepth;

                // å±¤é–“ã®é‡ãªã‚Šã‚’æ»‘ã‚‰ã‹ã«
                const layerTransition = (layerProgress * 15) - layerIndex;
                const nextLayerHeight = ((layerIndex + 1) / 15) * 1.2 * scale;
                pz = pz * (1 - layerTransition) + nextLayerHeight * layerTransition - cupDepth;

                // éå¸¸ã«å°ã•ãªãƒã‚¤ã‚ºã§æ»‘ã‚‰ã‹ã•ã‚’ä¿ã¤
                px += (Math.random() - 0.5) * 0.03 * scale;
                py += (Math.random() - 0.5) * 0.03 * scale;
                pz += (Math.random() - 0.5) * 0.03 * scale;

                positions[i * 3] = px;
                positions[i * 3 + 1] = py;
                positions[i * 3 + 2] = pz;

                // è‰²ã¯å±¤ã®æ·±ã•ã§æ±ºå®š
                const petalProgress = layerNormalized;

                // è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå¤–å´â†’å†…å´ï¼‰
                let color;
                if (petalProgress > 0.8) {
                    // å¤–å´ï¼šé’
                    color = new THREE.Color().setHSL(0.6, 0.8, 0.6);
                } else if (petalProgress > 0.6) {
                    // ã‚·ã‚¢ãƒ³
                    color = new THREE.Color().setHSL(0.55, 0.85, 0.65);
                } else if (petalProgress > 0.4) {
                    // ç´«
                    color = new THREE.Color().setHSL(0.75, 0.8, 0.7);
                } else if (petalProgress > 0.2) {
                    // ãƒ”ãƒ³ã‚¯
                    color = new THREE.Color().setHSL(0.9, 0.8, 0.75);
                } else {
                    // ä¸­å¿ƒï¼šã‚¤ã‚¨ãƒ­ãƒ¼
                    color = new THREE.Color().setHSL(0.15, 0.9, 0.75);
                }

                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚µã‚¤ã‚ºï¼ˆå¤§ãã‚ã§æ»‘ã‚‰ã‹ã«ï¼‰
                const sizeVariation = 0.9 + Math.random() * 0.2;
                sizes[i] = 0.15 * sizeVariation * scale;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.15 * scale,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false,
                map: createCircleTexture() // å††å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£ã§æ»‘ã‚‰ã‹ã«
            });

            // å††å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆï¼ˆã‚°ãƒ­ãƒ¼åŠ¹æœï¼‰
            function createCircleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.6, 'rgba(255,255,255,0.3)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);

                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            const particles = new THREE.Points(geometry, material);
            flowerGroup.add(particles);

            const allPetals = [particles];
            const allBaseColors = [];
            const centerPetals = [];

            // è¿½åŠ ã®ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            const sparkleCount = 200;
            const sparklePositions = new Float32Array(sparkleCount * 3);
            const sparkleColors = new Float32Array(sparkleCount * 3);
            const sparkleSizes = new Float32Array(sparkleCount);

            for (let i = 0; i < sparkleCount; i++) {
                const r = Math.random() * 3.5 * scale;
                const theta = Math.random() * Math.PI * 2;
                const zOffset = (Math.random() - 0.5) * 2 * scale;

                sparklePositions[i * 3] = Math.cos(theta) * r;
                sparklePositions[i * 3 + 1] = Math.sin(theta) * r;
                sparklePositions[i * 3 + 2] = zOffset;

                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 0.9, 0.8);
                sparkleColors[i * 3] = color.r;
                sparkleColors[i * 3 + 1] = color.g;
                sparkleColors[i * 3 + 2] = color.b;

                sparkleSizes[i] = (0.03 + Math.random() * 0.05) * scale;
            }

            const sparkleGeometry = new THREE.BufferGeometry();
            sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
            sparkleGeometry.setAttribute('color', new THREE.BufferAttribute(sparkleColors, 3));

            const sparkleMaterial = new THREE.PointsMaterial({
                size: 0.06 * scale,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
            flowerGroup.add(sparkles);

            flowerGroup.position.set(x, y, z);

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ‡ãƒ¼ã‚¿
            flowerGroup.userData = {
                originalScale: scale,
                mainParticles: particles,
                sparkles: sparkles,
                pulsePhase: Math.random() * Math.PI * 2
            };

            return flowerGroup;
        }

        // ğŸµ Web Audio API ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        let audioContext;
        let analyser;
        let dataArray;
        let isAudioActive = false;

        function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                console.log('ğŸµ Audio context initialized');
            } catch (error) {
                console.warn('ğŸš« Audio context not supported:', error);
            }
        }

        function connectVideoToAudio(videoElement) {
            console.log('ğŸ”— Attempting to connect video to audio...');
            console.log('ğŸ“º Video element:', videoElement);

            if (!audioContext || !analyser) {
                console.warn('ğŸš« Audio context not initialized, initializing now...');
                initAudioContext();
                if (!audioContext || !analyser) {
                    console.error('âŒ Failed to initialize audio context');
                    return;
                }
            }

            try {
                console.log('ğŸ”Š AudioContext state before connection:', audioContext.state);

                // AudioContextãŒsuspendedã®å ´åˆã€å†é–‹ã™ã‚‹
                if (audioContext.state === 'suspended') {
                    console.log('â¸ï¸ AudioContext is suspended, resuming...');
                    audioContext.resume().then(() => {
                        console.log('â–¶ï¸ AudioContext resumed successfully');
                    }).catch(err => {
                        console.error('âŒ Failed to resume AudioContext:', err);
                    });
                }

                // æ—¢ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (videoElement.audioSource) {
                    console.log('âœ… Video already connected to audio');
                    return;
                }

                console.log('ğŸ¬ Creating MediaElementSource...');
                const source = audioContext.createMediaElementSource(videoElement);
                console.log('ğŸµ Connecting source to analyser...');
                source.connect(analyser);
                console.log('ğŸ”Š Connecting analyser to destination...');
                analyser.connect(audioContext.destination);

                // æ¥ç¶šæ¸ˆã¿ãƒãƒ¼ã‚¯
                videoElement.audioSource = source;

                isAudioActive = true;
                updateAudioStatus('ğŸ¤ éŸ³å£°è§£æä¸­...', 'audio-active');
                console.log('âœ… Video successfully connected to audio analyser');

                // éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ãƒ†ã‚¹ãƒˆ
                setTimeout(() => {
                    if (analyser && dataArray) {
                        analyser.getByteFrequencyData(dataArray);
                        const testVolume = dataArray.reduce((sum, freq) => sum + freq, 0) / dataArray.length / 255;
                        console.log('ğŸ§ª Audio test - Volume level:', testVolume);
                        if (testVolume > 0.01) {
                            console.log('ğŸµ Audio is being detected!');
                        } else {
                            console.log('ğŸ”‡ No audio detected. Video might be muted or have no audio track.');
                        }
                    }
                }, 1000);

            } catch (error) {
                console.error('âŒ Failed to connect video to audio:', error);
                console.log('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });

                if (error.name === 'InvalidStateError') {
                    console.log('âš ï¸ InvalidStateError - Video already connected to another AudioContext!');
                    console.log('ğŸ’¡ This means ChocoDrop is using its own AudioContext.');
                    console.log('ğŸ”§ Trying alternative approach...');

                    // ä»£æ›¿æ¡ˆï¼šæ—¢å­˜ã® audio ã‹ã‚‰éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼
                    tryAlternativeAudioConnection(videoElement);
                } else if (error.name === 'NotSupportedError') {
                    console.log('âŒ NotSupportedError - Audio context creation failed');
                } else {
                    console.log('â“ Unknown error:', error.name);
                }
            }
        }

        function tryAlternativeAudioConnection(videoElement) {
            console.log('ğŸ”„ Trying alternative audio connection method...');

            // æ–¹æ³•1: Web Audio API ã‚’ä½¿ã‚ãšã«ã€ç›´æ¥ video ã®éŸ³é‡ã‚’ç›£è¦–
            const alternativeMonitor = () => {
                if (videoElement.paused) return;

                // ç°¡æ˜“çš„ãªéŸ³é‡æ¤œå‡ºï¼ˆå®Œç’§ã§ã¯ãªã„ãŒå‹•ä½œã™ã‚‹ï¼‰
                const currentTime = videoElement.currentTime;
                const duration = videoElement.duration;
                const volume = videoElement.volume;

                // å†ç”Ÿæ™‚é–“ãƒ™ãƒ¼ã‚¹ã®ç°¡æ˜“ãƒ‘ãƒ«ã‚¹ç”Ÿæˆ
                const timeBasedVolume = Math.sin(currentTime * 10) * 0.3 + 0.7;

                // éŸ³æ¥½ãŒå†ç”Ÿä¸­ãªã‚‰èŠ±ã‚’åå¿œã•ã›ã‚‹
                if (currentTime > 0 && !videoElement.paused && volume > 0) {
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’è¨­å®šã—ã¦èŠ±ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é§†å‹•
                    window.alternativeAudioData = {
                        volume: timeBasedVolume * volume,
                        isActive: true,
                        timestamp: Date.now()
                    };

                    if (!isAudioActive) {
                        isAudioActive = true;
                        updateAudioStatus('ğŸµ ä»£æ›¿éŸ³å£°ç›£è¦–ä¸­...', 'audio-active');
                        console.log('âœ… Alternative audio monitoring started');
                    }
                }
            };

            // 100msæ¯ã«ç›£è¦–
            videoElement.alternativeMonitorInterval = setInterval(alternativeMonitor, 100);
            console.log('ğŸ”„ Alternative audio monitoring interval started');
        }

        function updateAudioStatus(text, className) {
            const status = document.getElementById('audio-status');
            status.textContent = text;
            status.className = className;
        }

        // ğŸŒ¸ èŠ±ç•‘ã‚’ä½œæˆ
        const flowers = [];
        const flowerPositions = [
            [0, 0, 0],      // ä¸­å¤®
            [-8, 2, -5],    // å·¦
            [8, -1, -3],    // å³
            [-3, -3, -8],   // å·¦å¥¥
            [5, 3, -6],     // å³å¥¥
            [0, 5, -10],    // ä¸Šå¥¥
            [-6, -2, 3],    // å·¦æ‰‹å‰
            [7, 1, 4]       // å³æ‰‹å‰
        ];

        flowerPositions.forEach(pos => {
            const flower = createMusicFlower(pos[0], pos[1], pos[2], 0.8 + Math.random() * 0.4);
            flowers.push(flower);
            scene.add(flower);
        });

        // âœ¨ ç’°å¢ƒå…‰ï¼ˆå…¨ä½“ã‚’æŸ”ã‚‰ã‹ãç…§ã‚‰ã™ï¼‰
        const ambientLight = new THREE.AmbientLight(0x606080, 0.4);
        scene.add(ambientLight);

        // ğŸŒŸ ãƒ¡ã‚¤ãƒ³ã®ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆï¼ˆèŠ±ã‚’ç¾ã—ãç…§ã‚‰ã™ï¼‰
        const pointLight = new THREE.PointLight(0xFFE4E1, 1.2, 50);
        pointLight.position.set(0, 10, 5);
        scene.add(pointLight);

        // è¿½åŠ ã®ãƒ©ã‚¤ãƒˆ1ï¼ˆãƒ”ãƒ³ã‚¯ç³»ï¼‰
        const spotLight1 = new THREE.SpotLight(0xFF6B9D, 0.5);
        spotLight1.position.set(-10, 10, 10);
        spotLight1.target.position.set(0, 0, 0);
        scene.add(spotLight1);
        scene.add(spotLight1.target);

        // è¿½åŠ ã®ãƒ©ã‚¤ãƒˆ2ï¼ˆç´«ç³»ï¼‰
        const spotLight2 = new THREE.SpotLight(0x9F7AEA, 0.4);
        spotLight2.position.set(10, 8, -5);
        spotLight2.target.position.set(0, 0, 0);
        scene.add(spotLight2);
        scene.add(spotLight2.target);

        // ğŸ“· ã‚«ãƒ¡ãƒ©è¨­å®š
        camera.position.set(0, 3, 12);
        camera.lookAt(0, 0, 0);

        // ğŸ® ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;

        // ğŸ« ChocoDropåˆæœŸåŒ–
        console.log('ğŸ” Pre-ChocoDrop system check:');
        console.log('  - AudioContext support:', typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
        console.log('  - Video elements before ChocoDrop:', document.querySelectorAll('video').length);
        
        const chocoDrop = ChocoDrop.createChocoDrop(scene, {
            camera: camera,
            renderer: renderer,
            // GitHub Pagesãªã®ã§ç”Ÿæˆæ©Ÿèƒ½ãªã—ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ã¿
            serverUrl: null,
            skipServiceDialog: true, // GitHub Pagesç”¨ï¼šã‚µãƒ¼ãƒ“ã‚¹è¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ç„¡åŠ¹åŒ–
            disableServerConnection: true, // APIæ¥ç¶šã‚’å®Œå…¨ç„¡åŠ¹åŒ–
            sceneOptions: {
                enableMouseInteraction: true
            },
            onControlsToggle: (disabled) => {
                controls.enabled = !disabled;
            },
            onVideoAdded: (videoObject) => {
                console.log('ğŸ¬ Video object added to scene:', videoObject);
                console.log('ğŸ” Video object type:', typeof videoObject);
                console.log('ğŸ” Video object constructor:', videoObject.constructor.name);
                
                // ğŸš¨ é‡è¦: onVideoAddedãŒå‘¼ã°ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
                console.log('ğŸš¨ onVideoAdded callback was triggered!');
                console.log('ğŸ” DOM video elements at callback time:', document.querySelectorAll('video').length);
                
                // ğŸ” ChocoDrop Three.js ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè©³ç´°èª¿æŸ»
                console.log('ğŸ” Video object properties:', Object.keys(videoObject));
                console.log('ğŸ” Video object material:', videoObject.material);
                console.log('ğŸ” Video object material map:', videoObject.material?.map);
                console.log('ğŸ” Video object userData:', videoObject.userData);
                console.log('ğŸ” Video object children:', videoObject.children);
                
                // ğŸ” Sceneå†…ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª¿æŸ»
                console.log('ğŸ” Scene children count:', scene.children.length);
                scene.traverse((child) => {
                    if (child.material && child.material.map && child.material.map.image) {
                        console.log('ğŸ” Found textured object:', child);
                        console.log('ğŸ” Texture image:', child.material.map.image);
                        console.log('ğŸ” Image tagName:', child.material.map.image.tagName);
                    }
                });

                // ChocoDrop ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ video è¦ç´ ã‚’ç›´æ¥å–å¾—ã™ã‚‹è©¦ã¿
                if (videoObject && videoObject.userData && videoObject.userData.videoElement) {
                    console.log('âœ… Found video element in userData:', videoObject.userData.videoElement);
                    connectVideoToAudio(videoObject.userData.videoElement);
                    return;
                }

                // Materialã®mapã‹ã‚‰videoElementã‚’æ¢ã™
                if (videoObject.material && videoObject.material.map && videoObject.material.map.image) {
                    const videoEl = videoObject.material.map.image;
                    if (videoEl.tagName === 'VIDEO') {
                        console.log('âœ… Found video element in material.map.image:', videoEl);
                        connectVideoToAudio(videoEl);
                        return;
                    }
                }

                // ChocoDrop ã¯ Three.js ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã®ã§ã€å®Ÿéš›ã®videoè¦ç´ ã‚’æ¢ã™
                console.log('ğŸ” Searching for video elements in 500ms...');
                setTimeout(() => {
                    const videoElements = document.querySelectorAll('video');
                    console.log(`ğŸ“¹ Found ${videoElements.length} video elements`);
                    console.log('ğŸ”Š AudioContext state:', audioContext ? audioContext.state : 'not initialized');
                    console.log('ğŸµ Analyser exists:', !!analyser);
                    console.log('ğŸ“Š Data array exists:', !!dataArray);

                    if (videoElements.length === 0) {
                        console.warn('âŒ No video elements found! ChocoDrop might not have added the video to DOM yet.');
                        // å†è©¦è¡Œ
                        setTimeout(() => {
                            console.log('ğŸ”„ Retrying video search...');
                            const retryVideos = document.querySelectorAll('video');
                            console.log(`ğŸ“¹ Retry found ${retryVideos.length} video elements`);
                            if (retryVideos.length > 0) {
                                retryVideos.forEach(v => connectVideoToAudio(v));
                            }
                        }, 2000);
                    }

                    videoElements.forEach((videoElement, index) => {
                        console.log(`ğŸ¥ Video ${index}:`);
                        console.log(`  - src: ${videoElement.src}`);
                        console.log(`  - readyState: ${videoElement.readyState}`);
                        console.log(`  - paused: ${videoElement.paused}`);
                        console.log(`  - volume: ${videoElement.volume}`);
                        console.log(`  - muted: ${videoElement.muted}`);
                        console.log(`  - audioTracks: ${videoElement.audioTracks ? videoElement.audioTracks.length : 'not supported'}`);
                        console.log(`  - duration: ${videoElement.duration}`);
                        console.log(`  - currentTime: ${videoElement.currentTime}`);

                        // ã¾ã æ¥ç¶šã•ã‚Œã¦ã„ãªã„å‹•ç”»è¦ç´ ã‚’å‡¦ç†
                        if (!videoElement.audioSource) {
                            // å‹•ç”»ã‚’å‰é¢ã«é…ç½®
                            videoElement.style.zIndex = '10';
                            videoElement.style.position = 'relative';

                            // ã™ãã«æ¥ç¶šã‚’è©¦ã¿ã‚‹
                            connectVideoToAudio(videoElement);

                            // å‹•ç”»ã®æº–å‚™ãŒã§ãã¦ã‹ã‚‰å†æ¥ç¶š
                            videoElement.addEventListener('loadedmetadata', () => {
                                console.log('ğŸ“¹ Video metadata loaded, ensuring audio connection...');
                                if (!videoElement.audioSource) {
                                    connectVideoToAudio(videoElement);
                                }
                            });

                            // å†ç”Ÿé–‹å§‹æ™‚ã«ã‚‚ç¢ºå®Ÿã«æ¥ç¶š
                            videoElement.addEventListener('play', () => {
                                console.log('â–¶ï¸ Video playing, checking audio connection...');
                                if (!videoElement.audioSource) {
                                    connectVideoToAudio(videoElement);
                                }
                            });

                            // ã‚¯ãƒªãƒƒã‚¯ã§å†ç”Ÿ/ä¸€æ™‚åœæ­¢ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                            videoElement.addEventListener('click', () => {
                                if (videoElement.paused) {
                                    videoElement.play();
                                    // å†ç”Ÿé–‹å§‹æ™‚ã«å¼·åˆ¶çš„ã«éŸ³å£°ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                                    setTimeout(() => {
                                        if (!isAudioActive) {
                                            console.log('ğŸ”§ Force activating audio monitoring...');
                                            isAudioActive = true;
                                            updateAudioStatus('ğŸµ å¼·åˆ¶éŸ³å£°ç›£è¦–ä¸­...', 'audio-active');

                                            // ä»£æ›¿ç›£è¦–ã‚’é–‹å§‹
                                            tryAlternativeAudioConnection(videoElement);
                                        }
                                    }, 100);
                                } else {
                                    videoElement.pause();
                                }
                            });
                        }
                    });
                }, 500);  // ChocoDrop ãŒ DOM ã« video è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã®ã‚’å¾…ã¤
            }
        });

        // éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆæœŸåŒ–
        initAudioContext();
        
        // ğŸµ Three.js Sceneå†…ã®VideoTextureã‚’ç›£è¦–ã—ã¦éŸ³å£°æ¥ç¶š
        function monitorVideoTextures() {
            let foundVideo = false;
            
            scene.traverse((child) => {
                if (child.material && child.material.map && child.material.map.image) {
                    const image = child.material.map.image;
                    
                    // HTMLVideoElementã‚’ç™ºè¦‹
                    if (image instanceof HTMLVideoElement && !image.audioConnected) {
                        console.log('ğŸµ Found VideoTexture with HTMLVideoElement:', image);
                        console.log('  - src:', image.src);
                        console.log('  - readyState:', image.readyState);
                        console.log('  - paused:', image.paused);
                        
                        if (image.readyState >= 2) {
                            connectVideoToAudio(image);
                            image.audioConnected = true;
                            foundVideo = true;
                        }
                    }
                }
            });
            
            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
            if (foundVideo && !window.videoTextureFound) {
                console.log('âœ… VideoTexture audio connection established!');
                window.videoTextureFound = true;
            }
        }
        
        // 1ç§’ã”ã¨ã«ç›£è¦–
        setInterval(monitorVideoTextures, 1000);
        
        // åˆå›å®Ÿè¡Œ
        setTimeout(monitorVideoTextures, 2000);

        console.log('ğŸ« ChocoDrop Music Garden initialized');
        console.log('Press @ key to activate command interface');
        console.log('ä½¿ç”¨ä¾‹: ğŸ«ã‚¢ã‚¤ã‚³ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§UIèµ·å‹•ã€å‹•ç”»ã‚’é…ç½®ã—ã¦éŸ³æ¥½åå¿œ!');

        // ğŸ¬ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // éŸ³å£°è§£æï¼ˆãƒ‡ãƒãƒƒã‚°å¼·åŒ–ç‰ˆï¼‰
            let volume = 0;
            let frequencies = new Array(8).fill(0);

            // ãƒ‡ãƒãƒƒã‚°: 5ç§’ã”ã¨ã«çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
            if (!window.lastDebugLog || Date.now() - window.lastDebugLog > 5000) {
                console.log('ğŸ” Audio Debug Status:');
                console.log('  - isAudioActive:', isAudioActive);
                console.log('  - analyser exists:', !!analyser);
                console.log('  - audioContext state:', audioContext ? audioContext.state : 'none');
                console.log('  - dataArray exists:', !!dataArray);
                console.log('  - video elements count:', document.querySelectorAll('video').length);
                console.log('  - alternative audio:', window.alternativeAudioData ? window.alternativeAudioData.isActive : 'none');
                window.lastDebugLog = Date.now();
            }

            if (isAudioActive && analyser) {
                analyser.getByteFrequencyData(dataArray);

                // å…¨ä½“éŸ³é‡ã‚’è¨ˆç®—
                volume = dataArray.reduce((sum, freq) => sum + freq, 0) / dataArray.length / 255;

                // éŸ³æ¥½æ¤œå‡ºæ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ï¼ˆãƒ­ã‚°ãªã—ï¼‰
                if (volume > 0.005) {
                    if (!window.audioDetected) {
                        updateAudioStatus('ğŸµ éŸ³æ¥½åå¿œä¸­!', 'audio-active');
                        window.audioDetected = true;
                    }
                } else if (window.audioDetected) {
                    updateAudioStatus('ğŸ”‡ éŸ³å£°å¾…æ©Ÿä¸­...', 'audio-waiting');
                    window.audioDetected = false;
                }

                // å‘¨æ³¢æ•°å¸¯åŸŸã‚’åˆ†æï¼ˆä½éŸ³ã€œé«˜éŸ³ï¼‰
                const bands = 8;
                const bandSize = Math.floor(dataArray.length / bands);
                for (let i = 0; i < bands; i++) {
                    let sum = 0;
                    for (let j = 0; j < bandSize; j++) {
                        sum += dataArray[i * bandSize + j];
                    }
                    frequencies[i] = sum / bandSize / 255;
                }
            } else if (window.alternativeAudioData && window.alternativeAudioData.isActive) {
                // ä»£æ›¿éŸ³å£°ç›£è¦–ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                const altData = window.alternativeAudioData;
                const timeSinceUpdate = Date.now() - altData.timestamp;

                // æœ€æ–°ãƒ‡ãƒ¼ã‚¿ï¼ˆ1ç§’ä»¥å†…ï¼‰ã®å ´åˆã®ã¿ä½¿ç”¨
                if (timeSinceUpdate < 1000) {
                    volume = altData.volume;
                    // ç°¡æ˜“çš„ãªå‘¨æ³¢æ•°ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
                    for (let i = 0; i < 8; i++) {
                        frequencies[i] = Math.sin(time * (i + 1) * 2) * volume * 0.5 + 0.5;
                    }

                    if (!window.alternativeAudioDetected) {
                        console.log('ğŸ”„ Using alternative audio data! Volume:', volume);
                        window.alternativeAudioDetected = true;
                    }
                }
            }

            // ğŸŒ¸ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«èŠ±ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            flowers.forEach((flower, index) => {
                const userData = flower.userData;
                const mainParticles = userData.mainParticles;
                const sparkles = userData.sparkles;

                // éŸ³æ¥½ã«åå¿œã™ã‚‹ã‚¹ã‚±ãƒ¼ãƒ«
                if (volume > 0.005) {
                    const basePulse = Math.sin(time + userData.pulsePhase) * 0.1 + 1;
                    const musicScale = 1 + volume * 0.3;
                    flower.scale.setScalar(userData.originalScale * basePulse * musicScale);
                } else {
                    flower.scale.setScalar(userData.originalScale);
                }

                // ãƒ¡ã‚¤ãƒ³ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (mainParticles) {
                    // å›è»¢
                    mainParticles.rotation.z += 0.002 + volume * 0.01;

                    // éŸ³æ¥½ã«åˆã‚ã›ã¦è‰²ã‚’å¤‰åŒ–
                    const colors = mainParticles.geometry.attributes.color.array;
                    for (let i = 0; i < colors.length; i += 3) {
                        const hue = (colors[i] * 0.3 + colors[i + 1] * 0.59 + colors[i + 2] * 0.11); // è¼åº¦
                        const shift = volume * 0.1 * Math.sin(time + i * 0.1);

                        const baseColor = new THREE.Color(colors[i], colors[i + 1], colors[i + 2]);
                        const hsl = {};
                        baseColor.getHSL(hsl);

                        if (volume > 0.005) {
                            const newColor = new THREE.Color().setHSL(
                                (hsl.h + shift) % 1,
                                Math.min(1, hsl.s + volume * 0.1),
                                Math.min(1, hsl.l + volume * 0.15)
                            );
                            colors[i] = newColor.r;
                            colors[i + 1] = newColor.g;
                            colors[i + 2] = newColor.b;
                        }
                    }
                    mainParticles.geometry.attributes.color.needsUpdate = true;

                    // é€æ˜åº¦ã¨ã‚µã‚¤ã‚º
                    mainParticles.material.opacity = 0.8 + volume * 0.2;
                    mainParticles.material.size = (0.08 + volume * 0.04) * userData.originalScale;
                }

                // ã‚­ãƒ©ã‚­ãƒ©ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (sparkles) {
                    sparkles.rotation.z -= 0.003 + volume * 0.015;
                    sparkles.rotation.y += 0.002;

                    const sparklePositions = sparkles.geometry.attributes.position.array;
                    for (let i = 0; i < sparklePositions.length; i += 3) {
                        const wave = Math.sin(time * 2 + i * 0.5) * volume * 0.2;
                        sparklePositions[i + 2] += wave * 0.1;
                    }
                    sparkles.geometry.attributes.position.needsUpdate = true;

                    sparkles.material.opacity = 0.6 + volume * 0.4;
                    sparkles.material.size = (0.06 + volume * 0.08) * userData.originalScale;
                }

                // èŠ±å…¨ä½“ã®å›è»¢
                if (volume > 0.005) {
                    flower.rotation.x = Math.sin(time * 0.3 + index) * 0.08;
                    flower.rotation.y = Math.cos(time * 0.2 + index) * 0.04;
                }
            });

            // ãƒ©ã‚¤ãƒˆã‚‚éŸ³æ¥½ã«åå¿œ
            pointLight.intensity = 0.8 + volume * 0.5;
            pointLight.color.setHSL((time * 0.1) % 1, 0.5, 1);

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // ğŸ“± ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ğŸ¯ ãƒ’ãƒ³ãƒˆãƒ‘ãƒãƒ«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
        let autoHideTimer = null;

        function hideInfoPanel() {
            const infoPanel = document.getElementById('info');
            const hintToggle = document.getElementById('hint-toggle');

            infoPanel.classList.add('hidden');
            setTimeout(() => {
                infoPanel.style.display = 'none';
                hintToggle.style.display = 'block';
            }, 300);

            if (autoHideTimer) {
                clearTimeout(autoHideTimer);
            }
        }

        function showInfoPanel() {
            const infoPanel = document.getElementById('info');
            const hintToggle = document.getElementById('hint-toggle');

            hintToggle.style.display = 'none';
            infoPanel.style.display = 'block';
            setTimeout(() => {
                infoPanel.classList.remove('hidden');
            }, 10);

            // 30ç§’å¾Œã«è‡ªå‹•éè¡¨ç¤º
            autoHideTimer = setTimeout(hideInfoPanel, 30000);
        }

        // ãƒ’ãƒ³ãƒˆãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('hint-toggle').onclick = showInfoPanel;

        // 30ç§’å¾Œã®è‡ªå‹•éè¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
        autoHideTimer = setTimeout(hideInfoPanel, 30000);

        console.log('âœ… éŸ³æ¥½ã®èŠ±åœ’ãŒæº–å‚™å®Œäº†ï¼ğŸµ æ­Œã£ã¦ãŠèŠ±ã‚’å’²ã‹ã›ã¾ã—ã‚‡ã†');

    </script>
</body>
</html>