<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>侘び寂び - Wabi-Sabi Space | ChocoDrop Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Yu Gothic', 'Hiragino Sans', sans-serif;
            background: #fafafa; /* ミニマルな白 */
        }
        canvas {
            display: block;
        }
        
        /* ChocoDrop 要素を墨絵風にカスタマイズ */
        .chocodrop-media {
            border: 2px solid rgba(30, 30, 30, 0.8) !important;
            background: rgba(250, 250, 250, 0.9) !important;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3) !important;
        }
        
        .chocodrop-overlay {
            background: rgba(30, 30, 30, 0.8) !important;
            border: none !important;
        }
        
        .chocodrop-button {
            background: rgba(30, 30, 30, 0.9) !important;
            color: white !important;
            border: 1px solid rgba(30, 30, 30, 0.9) !important;
        }
        
        /* オレンジ色の要素を完全に除去 */
        .chocodrop-frame,
        .chocodrop-selection-box,
        .chocodrop-resize-handle {
            border-color: rgba(30, 30, 30, 0.8) !important;
            background-color: transparent !important;
        }
        
        .chocodrop-highlight {
            background-color: rgba(30, 30, 30, 0.1) !important;
            border-color: rgba(30, 30, 30, 0.8) !important;
        }
        
        /* 全ての赤/オレンジ系の色を強制的に墨色に変更 */
        * {
            --chocodrop-primary-color: rgba(30, 30, 30, 0.9) !important;
            --chocodrop-accent-color: rgba(30, 30, 30, 0.8) !important;
        }
        
        div[style*="background-color: rgb(255"],
        div[style*="background-color: #ff"],
        div[style*="background: rgb(255"],
        div[style*="background: #ff"],
        div[style*="border-color: rgb(255"],
        div[style*="border-color: #ff"] {
            background-color: rgba(30, 30, 30, 0.1) !important;
            border-color: rgba(30, 30, 30, 0.8) !important;
        }
        
        /* ChocoDrop で使われる可能性のある全ての要素 */
        div, span, button {
            filter: none !important;
        }
        
        /* より限定的なスタイル上書き */
        .chocodrop-container * {
            background-color: rgba(250, 250, 250, 0.9) !important;
            border-color: rgba(30, 30, 30, 0.8) !important;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="../../dist/chocodrop.umd.js"></script>

    <script>
        // 🍵 侘び寂びの世界 - Wabi-Sabi Space

        // Three.js 基本設定
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "default"
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 🎨 ミニマルな白い空間
        function createMinimalBackground() {
            // シンプルな白い背景色
            scene.background = new THREE.Color(0xfafafa);
            // 霧効果で奥行き感
            scene.fog = new THREE.Fog(0xfafafa, 30, 100);
        }

        // 🖌️ 墨絵風の線画・漢字スプライト作成
        function createInkDrawing(type, x = 0, y = 0, z = 0) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 透明背景
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 墨の質感設定
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (type === 'mountain') {
                // 🖌️ 習字風の太い筆線
                ctx.strokeStyle = 'rgba(10, 10, 10, 0.95)';
                ctx.lineWidth = 25;
                
                // 流れるような太い線を描く
                ctx.beginPath();
                ctx.moveTo(100, 100);
                ctx.bezierCurveTo(200, 150, 300, 200, 400, 120);
                ctx.bezierCurveTo(450, 100, 480, 180, 420, 250);
                ctx.bezierCurveTo(380, 300, 300, 350, 200, 320);
                ctx.bezierCurveTo(150, 310, 120, 280, 140, 240);
                
                // 筆の強弱を表現
                for (let i = 0; i < 2; i++) {
                    ctx.lineWidth = 25 - i * 5;
                    ctx.globalAlpha = 0.8 + i * 0.15;
                    ctx.stroke();
                }
                
            } else if (type === 'bird') {
                // 🖌️ 習字風の太い曲線
                ctx.strokeStyle = 'rgba(10, 10, 10, 0.95)';
                ctx.lineWidth = 20;
                
                // 躍動感のある太い線
                ctx.beginPath();
                ctx.moveTo(120, 200);
                ctx.bezierCurveTo(180, 120, 250, 180, 320, 140);
                ctx.bezierCurveTo(380, 120, 420, 200, 400, 280);
                ctx.bezierCurveTo(350, 350, 280, 320, 220, 380);
                ctx.bezierCurveTo(180, 400, 140, 350, 120, 300);
                
                // 筆の強弱
                for (let i = 0; i < 2; i++) {
                    ctx.lineWidth = 20 - i * 4;
                    ctx.globalAlpha = 0.85 + i * 0.1;
                    ctx.stroke();
                }
                
            } else if (type === 'bamboo') {
                // 🖌️ 習字風の太い縦線
                ctx.strokeStyle = 'rgba(10, 10, 10, 0.95)';
                ctx.lineWidth = 18;
                
                // 太い縦の筆線
                ctx.beginPath();
                ctx.moveTo(180, 80);
                ctx.bezierCurveTo(185, 150, 190, 250, 185, 350);
                ctx.bezierCurveTo(180, 400, 175, 450, 170, 480);
                
                // 2本目の線
                ctx.moveTo(220, 70);
                ctx.bezierCurveTo(225, 140, 230, 240, 225, 340);
                ctx.bezierCurveTo(220, 390, 215, 440, 210, 470);
                
                // 3本目の線
                ctx.moveTo(260, 90);
                ctx.bezierCurveTo(265, 160, 270, 260, 265, 360);
                ctx.bezierCurveTo(260, 410, 255, 460, 250, 490);
                
                // 筆の強弱
                for (let i = 0; i < 2; i++) {
                    ctx.lineWidth = 18 - i * 3;
                    ctx.globalAlpha = 0.9 + i * 0.05;
                    ctx.stroke();
                }
                
            } else {
                // 🖌️ 習字風の太い漢字
                ctx.font = 'bold 140px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(5, 5, 5, 0.95)';
                ctx.strokeStyle = 'rgba(5, 5, 5, 0.95)';
                ctx.lineWidth = 3;
                
                // 太い文字を重ね描きで表現
                for (let i = 0; i < 3; i++) {
                    ctx.save();
                    ctx.translate(
                        (Math.random() - 0.5) * 1,
                        (Math.random() - 0.5) * 1
                    );
                    ctx.globalAlpha = 0.7 + (i * 0.1);
                    
                    // 文字を塗りつぶしで太く
                    ctx.fillText(type, 256, 256);
                    // 輪郭も描いて更に太く
                    ctx.strokeText(type, 256, 256);
                    
                    ctx.restore();
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.98, // より濃く
                alphaTest: 0.1
            });

            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 8, 1);
            sprite.position.set(x, y, z);

            // アニメーション用データ
            sprite.userData = {
                originalY: y,
                floatSpeed: 0.0005 + Math.random() * 0.001,
                rotationSpeed: (Math.random() - 0.5) * 0.0005,
                floatAmplitude: 1 + Math.random() * 2,
                phase: Math.random() * Math.PI * 2
            };

            return sprite;
        }

        // 🌿 光る苔エフェクト（下部）
        function createMossGlow() {
            const mossGroup = new THREE.Group();

            // 苔のパーティクル
            const mossGeometry = new THREE.BufferGeometry();
            const mossCount = 200;
            const positions = new Float32Array(mossCount * 3);
            const colors = new Float32Array(mossCount * 3);
            const sizes = new Float32Array(mossCount);

            for (let i = 0; i < mossCount; i++) {
                const i3 = i * 3;

                // 下部に配置
                positions[i3] = (Math.random() - 0.5) * 30;
                positions[i3 + 1] = -10 + Math.random() * 2;
                positions[i3 + 2] = (Math.random() - 0.5) * 10;

                // 緑色のグラデーション
                const brightness = 0.3 + Math.random() * 0.7;
                colors[i3] = 0.2 * brightness;
                colors[i3 + 1] = 0.8 * brightness;
                colors[i3 + 2] = 0.3 * brightness;

                sizes[i] = Math.random() * 3 + 1;
            }

            mossGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            mossGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            mossGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const mossMaterial = new THREE.PointsMaterial({
                size: 2,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const moss = new THREE.Points(mossGeometry, mossMaterial);
            mossGroup.add(moss);

            // 苔の光パルス用データ
            mossGroup.userData = {
                pulseSpeed: 0.002,
                time: 0
            };

            return mossGroup;
        }

        // 🍂 紅葉パーティクル
        function createMapleLeaf() {
            const leafGeometry = new THREE.BufferGeometry();
            const leafCount = 5; // 控えめに
            const positions = new Float32Array(leafCount * 3);
            const colors = new Float32Array(leafCount * 3);

            for (let i = 0; i < leafCount; i++) {
                const i3 = i * 3;

                positions[i3] = (Math.random() - 0.5) * 20;
                positions[i3 + 1] = 10 + Math.random() * 5;
                positions[i3 + 2] = (Math.random() - 0.5) * 10;

                // 紅葉の赤
                colors[i3] = 0.8 + Math.random() * 0.2;
                colors[i3 + 1] = 0.1 + Math.random() * 0.2;
                colors[i3 + 2] = 0.1;
            }

            leafGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            leafGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const leafMaterial = new THREE.PointsMaterial({
                size: 5,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.7
            });

            const leaves = new THREE.Points(leafGeometry, leafMaterial);

            // 落下アニメーション用
            leaves.userData = {
                fallSpeed: 0.01,
                swaySpeed: 0.002,
                time: 0
            };

            return leaves;
        }

        // シーン構築
        createMinimalBackground();

        // 墨絵風の絵と漢字を配置
        const inkElements = ['mountain', 'bird', 'bamboo', '静', '風', '花', '月'];
        const inkSprites = [];

        inkElements.forEach((kanji, index) => {
            const angle = (index / inkElements.length) * Math.PI * 2;
            const radius = 12;
            const sprite = createInkDrawing(
                kanji,
                Math.cos(angle) * radius,
                (Math.random() - 0.5) * 5,
                Math.sin(angle) * radius
            );
            inkSprites.push(sprite);
            scene.add(sprite);
        });

        // 光る苔を追加
        const moss = createMossGlow();
        scene.add(moss);

        // 紅葉を追加
        const mapleLeaves = createMapleLeaf();
        scene.add(mapleLeaves);

        // ライティング（ミニマル調整）
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 0.2);
        spotLight.position.set(0, 20, 10);
        scene.add(spotLight);

        // カメラ位置
        camera.position.set(0, 0, 25);
        camera.lookAt(0, 0, 0);

        // コントロール
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 50;

        // 🍫 ChocoDrop初期化
        let chocoDrop;

        function initChocoDrop() {
            try {
                chocoDrop = ChocoDrop.createChocoDrop(scene, {
                    camera: camera,
                    renderer: renderer,
                    serverUrl: null, // GitHub Pagesなので
                    disableServerConnection: true, // API接続を無効化
                    sceneOptions: {
                        enableMouseInteraction: true
                    },
                    onControlsToggle: (disabled) => {
                        controls.enabled = !disabled;
                    }
                });

                console.log('🍵 侘び寂びの世界へようこそ。@キーで始まります。');

            } catch (error) {
                console.error('ChocoDrop initialization failed:', error);
            }
        }

        setTimeout(initChocoDrop, 1000);

        // 🎨 ChocoDrop のオレンジ色を動的に墨色に変更
        function enforceInkStyle() {
            const elements = document.querySelectorAll('*');
            elements.forEach(el => {
                const style = el.style;
                const computedStyle = window.getComputedStyle(el);
                
                // オレンジ/赤系の背景色を墨色に変更
                if (style.backgroundColor && 
                    (style.backgroundColor.includes('rgb(255') || 
                     style.backgroundColor.includes('#ff') ||
                     style.backgroundColor.includes('orange'))) {
                    el.style.backgroundColor = 'rgba(30, 30, 30, 0.1)';
                    el.style.borderColor = 'rgba(30, 30, 30, 0.8)';
                }
                
                // 境界線の色も変更
                if (style.borderColor && 
                    (style.borderColor.includes('rgb(255') || 
                     style.borderColor.includes('#ff'))) {
                    el.style.borderColor = 'rgba(30, 30, 30, 0.8)';
                }
            });
        }

        // 定期的にスタイルをチェック・修正
        setInterval(enforceInkStyle, 500);

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // 墨絵の浮遊アニメーション
            inkSprites.forEach(sprite => {
                const userData = sprite.userData;
                sprite.position.y = userData.originalY +
                    Math.sin(time * userData.floatSpeed + userData.phase) * userData.floatAmplitude;
                sprite.rotation.z += userData.rotationSpeed;
            });

            // 苔の光パルス
            if (moss.userData) {
                moss.userData.time = time;
                const pulse = Math.sin(time * moss.userData.pulseSpeed) * 0.5 + 0.5;
                moss.children[0].material.opacity = 0.4 + pulse * 0.4;
            }

            // 紅葉の落下
            if (mapleLeaves.userData) {
                mapleLeaves.userData.time = time;
                const positions = mapleLeaves.geometry.attributes.position.array;

                for (let i = 0; i < positions.length; i += 3) {
                    // ゆっくり落下
                    positions[i + 1] -= mapleLeaves.userData.fallSpeed;

                    // 左右に揺れる
                    positions[i] += Math.sin(time * mapleLeaves.userData.swaySpeed + i) * 0.01;

                    // 下まで落ちたら上に戻す
                    if (positions[i + 1] < -10) {
                        positions[i + 1] = 15;
                        positions[i] = (Math.random() - 0.5) * 20;
                    }
                }

                mapleLeaves.geometry.attributes.position.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // レスポンシブ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>